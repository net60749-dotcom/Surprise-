<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Journey Through the Land of the Dead</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap');
  body {
    margin: 0; overflow: hidden;
    background: linear-gradient(180deg, #1c0b30 0%, #ff8c00 100%);
    font-family: 'Montserrat', sans-serif;
    user-select: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #230041;
    border: 5px solid #ffb800;
    border-radius: 15px;
  }
  #score {
    position: fixed;
    top: 20px;
    left: 20px;
    color: #ffd500;
    font-size: 24px;
    font-weight: 700;
    text-shadow: 1px 1px 6px #000;
    z-index: 100;
  }
  #gameover {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ffb800;
    font-size: 36px;
    font-weight: 900;
    text-align: center;
    background: rgba(0,0,0,0.7);
    padding: 30px;
    border-radius: 20px;
    display: none;
    z-index: 200;
    box-shadow: 0 0 15px 5px #ffb800;
  }
  #gameover button {
    margin-top: 20px;
    background: #ffb800;
    border: none;
    padding: 12px 30px;
    font-weight: 700;
    font-size: 20px;
    color: #230041;
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #gameover button:hover {
    background: #ffd500;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<div id="gameover">
  <div>Game Over!</div>
  <button id="restartBtn">Restart</button>
</div>

<canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
// -- Setup canvas and context
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const scoreDisplay = document.getElementById('score');
const gameOverScreen = document.getElementById('gameover');
const restartBtn = document.getElementById('restartBtn');

const GRAVITY = 0.5;
const FLOOR_Y = canvas.height - 70;

let keys = {};

// Load sounds
const sounds = {
  jump: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
  collect: new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg'),
  hit: new Audio('https://actions.google.com/sounds/v1/cartoon/metal_clang.ogg'),
};

// Player sprite parameters
const playerWidth = 50;
const playerHeight = 70;

// Marigold collectible parameters
const marigoldRadius = 15;

// Enemy parameters
const enemyWidth = 50;
const enemyHeight = 70;

class Player {
  constructor() {
    this.x = 100;
    this.y = FLOOR_Y - playerHeight;
    this.vx = 0;
    this.vy = 0;
    this.speed = 5;
    this.jumpPower = 12;
    this.isOnGround = true;
    this.color = '#ffbb00';
    this.frameCount = 0;
  }
  draw() {
    // Simple cartoon Miguel: body + guitar outline shape
    ctx.fillStyle = '#ffbb00'; // bright orange shirt
    ctx.fillRect(this.x, this.y, playerWidth, playerHeight);
    // Head
    ctx.fillStyle = '#ffdbac';
    ctx.beginPath();
    ctx.ellipse(this.x + playerWidth/2, this.y - 20, 25, 30, 0, 0, Math.PI*2);
    ctx.fill();
    // Eyes
    ctx.fillStyle = '#230041';
    ctx.beginPath();
    ctx.ellipse(this.x + playerWidth/2 - 10, this.y - 25, 5, 8, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + playerWidth/2 + 10, this.y - 25, 5, 8, 0, 0, Math.PI*2);
    ctx.fill();
    // Guitar on back (simple triangle)
    ctx.fillStyle = '#8b4513';
    ctx.beginPath();
    ctx.moveTo(this.x + playerWidth + 5, this.y + 20);
    ctx.lineTo(this.x + playerWidth + 30, this.y + 10);
    ctx.lineTo(this.x + playerWidth + 5, this.y + 50);
    ctx.closePath();
    ctx.fill();
  }
  update() {
    // Horizontal movement
    if (keys['ArrowRight']) {
      this.vx = this.speed;
    } else if (keys['ArrowLeft']) {
      this.vx = -this.speed;
    } else {
      this.vx = 0;
    }
    this.x += this.vx;

    // Keep inside canvas
    if (this.x < 0) this.x = 0;
    if (this.x + playerWidth > canvas.width) this.x = canvas.width - playerWidth;

    // Gravity
    this.vy += GRAVITY;
    this.y += this.vy;

    // Floor collision
    if (this.y + playerHeight >= FLOOR_Y) {
      this.y = FLOOR_Y - playerHeight;
      this.vy = 0;
      this.isOnGround = true;
    } else {
      this.isOnGround = false;
    }

    this.frameCount++;
  }
  jump() {
    if (this.isOnGround) {
      this.vy = -this.jumpPower;
      this.isOnGround = false;
      sounds.jump.play();
    }
  }
}

class Marigold {
  constructor() {
    this.x = Math.random() * (canvas.width - marigoldRadius*2) + marigoldRadius;
    this.y = Math.random() * (FLOOR_Y - 150) + 20;
    this.radius = marigoldRadius;
    this.collected = false;
    this.pulse = 0;
    this.pulseDir = 1;
  }
  draw() {
    // Pulse animation
    this.pulse += this.pulseDir * 0.05;
    if (this.pulse > 1 || this.pulse < 0) this.pulseDir *= -1;
    const size = this.radius + this.pulse * 5;

    ctx.save();
    ctx.translate(this.x, this.y);
    // Petals (simple circle petals)
    ctx.fillStyle = '#ffb600';
    for(let i=0; i<8; i++) {
      ctx.beginPath();
      ctx.ellipse(Math.cos(i*Math.PI/4)*size, Math.sin(i*Math.PI/4)*size/2, size/3, size/1.8, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Center
    ctx.beginPath();
    ctx.fillStyle = '#ff6f00';
    ctx.ellipse(0,0,size/2,size/2,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

class Enemy {
  constructor() {
    this.x = Math.random() * (canvas.width - enemyWidth);
    this.y = FLOOR_Y - enemyHeight;
    this.vx = (Math.random() < 0.5 ? -1 : 1) * (2 + Math.random()*2);
    this.color = '#9b59b6';
    this.width = enemyWidth;
    this.height = enemyHeight;
  }
  draw() {
    // Simple ghostly figure
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y + this.height);
    ctx.lineTo(this.x, this.y + this.height/3);
    ctx.quadraticCurveTo(this.x + this.width/2, this.y - this.height/2, this.x + this.width, this.y + this.height/3);
    ctx.lineTo(this.x + this.width, this.y + this.height);
    ctx.closePath();
    ctx.fill();

    // Eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(this.x + this.width/3, this.y + this.height/2.5, 8, 12, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + this.width*2/3, this.y + this.height/2.5, 8, 12, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(this.x + this.width/3, this.y + this.height/2.5, 4, 6, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + this.width*2/3, this.y + this.height/2.5, 4, 6, 0, 0, Math.PI*2);
    ctx.fill();
  }
  update() {
    this.x += this.vx;
    if(this.x < 0 || this.x + this.width > canvas.width) this.vx *= -1;
  }
}

// Game variables
let player = new Player();
let marigolds = [];
let enemies = [];
let score = 0;
let gameRunning = true;

// Initialize marigolds and enemies
function init() {
  marigolds = [];
  enemies = [];
  score = 0;
  player.x = 100;
  player.y = FLOOR_Y - playerHeight;
  gameRunning = true;
  gameOverScreen.style.display = 'none';

  // Create 6 marigolds randomly placed
  for(let i=0; i<6; i++) {
    marigolds.push(new Marigold());
  }
  // Create 3 enemies
  for(let i=0; i<3; i++) {
    enemies.push(new Enemy());
  }
  updateScore();
}

// Update score display
function updateScore() {
  scoreDisplay.textContent = `Score: ${score}`;
}

// Check collision helper
function isColliding(rect1, rect2) {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
}

// Check circle-rect collision
function circleRectColliding(circle, rect) {
  const distX = Math.abs(circle.x - rect.x - rect.width/2);
  const distY = Math.abs(circle.y - rect.y - rect.height/2);

  if (distX > (rect.width/2 + circle.radius)) return false;
  if (distY > (rect.height/2 + circle.radius)) return false;

  if (distX <= (rect.width/2)) return true;
  if (distY <= (rect.height/2)) return true;

  const dx = distX - rect.width/2;
  const dy = distY - rect.height/2;
  return (dx*dx + dy*dy <= (circle.radius*circle.radius));
}

// Game Over
function gameOver() {
  gameRunning = false;
  gameOverScreen.style.display = 'block';
}

// Handle input
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if(e.key === ' ' || e.key === 'ArrowUp') {
    player.jump();
  }
});
window.addEventListener('keyup', e => {
  keys[e.key] = false;
});

// Game Loop
function gameLoop() {
  if (!gameRunning) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw ground
  ctx.fillStyle = '#663300';
  ctx.fillRect(0, FLOOR_Y, canvas.width, canvas.height - FLOOR_Y);

  // Draw marigolds and check collection
  for(let m of marigolds) {
    if(!m.collected) {
      m.draw();
      if(circleRectColliding(m, player)) {
        m.collected = true;
        score++;
        sounds.collect.currentTime = 0;
        sounds.collect.play();
        updateScore();
      }
    }
  }

  // Update and draw enemies, check collision
  for(let enemy of enemies) {
    enemy.update();
    enemy.draw();
    if(isColliding(player, enemy)) {
      sounds.hit.play();
      gameOver();
    }
  }

  player.update();
  player.draw();

  requestAnimationFrame(gameLoop);
}

// Restart button
restartBtn.addEventListener('click', () => {
  init();
  gameLoop();
});

// Start game
init();
gameLoop();
</script>
</body>
  </html>
